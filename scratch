

@parser('standard : COMMENT | element | block | VARIABLE | STRING')
def p_standard(p):
    p[0] = p[1]










def p_element(p)

tokens = '(!', '(:', '(/', '(~', '(', '{%', '{', '~', '}', '%}', ')', r'"([^"\\]*(?:\\.[^"\\]*)*)"'

DOCTYPES = {
    '5': 'HTML',
}

class Hisp:
    def __init__(self, slash=False):
        self.slash = False

# Utilities :::1

def _attrs(pairs):
    return u' '.join(u'%s="%s"' % (k, u' '.join(v)) for (k, v) in pairs)


# Exceptions :::1

class ParseError(Exception):
    pass


# Parsers :::1

def parseone(text, parsers):
    for parser in parsers:
        try:
            return parse(text)
        except ParseError:
            pass
    raise


def parselist(text, parsers):
    if text:
        parsed, remainder = parseone(text, parsers)
        yield parsed
        for component in parselist(remainder, parsers):
            yield component


def parse(text):
    try:
        dt, rest = doctype.parse(text)
    except ParseError:
        dt, rest = '', text
    return dt + ''.join(parselist(rest, top))


# Decorators :::1

def parseatom(regex):
    regex = re.compile(r'^\s*' + regex + r'\s*', re.IGNORECASE | re.DOTALL)
    def decorator(fn):
        def doparse(text):
            result = regex.split(text, 1)
            groups, remainder = result[:-1], result[-1]
            if not groups:
                raise ParseError('Error parsing %s' % text)
            return fn(*groups), remainder
        return doparse
    return decorator


def parsexp(regex, heads, content=()):
    regex = re.compile(r'^\s*' + regex + r'\s*', re.IGNORECASE | re.DOTALL)
    content = top if content is None else content
    def decorator(fn):
        def doparse(text):
            try:
                inner, remainder = regex.split(text, 1)
            except ValueError:
                raise ParseError('Error parsing %s' % text)
            head, rest = parseone(inner, heads)
            contents = parselist(rest, content)
            return fn(head, contents), remainder
        return doparse
    return decorator


# Atoms :::1

@parseatom(r'\(!([^)]*)\)')
def comment(atom):
    return u'<!--%s-->' % atom


@parseatom(r'\(~(5|4|4S|4T|4F|X|XS|XF|XT|3|2)\)')
def doctype(dt):
    return u'<!DOCTYPE %s>' % DOCTYPES[dt]


@parseatom(r'([\w-]+)?((?:\.[\w-]+)*)((?:#[\w-]+)?)((?:\.[\w-]+)*)')
def tag(tag, cls1, id, cls2):
    attrs = [('class', cls) for cls in '.'.split(chain(cls1, cls2))]
    attrs.append(('id', id))
    return (tag or 'div', attrs)


@parseatom(r'"([^"\\]*(?:\\.[^"\\]*)*)"')
def string(atom):
    return atom


@parseatom(r'([\w-]+)')
def name(atom):
    return atom


@parseatom(r'([^(){}[]<>"\s]+)')
def word(atom):
    return atom


@parseatom(r'\{([^}]*)\}')
def variable(atom):
    return '{{%s}}' % atom


@parseatom(r'%\s*(([^\s%]*)\s*[^%]*)\s*%')
def head(full, name):
    return full, name


# Expressions :::1

@parsexp(r'\{%(.*)%\}', (head,))
def block((full, name), contents):
    if contents:
        return u'{{%{}%}}{}{{%end{}%}}'.format(full, ''.join(contents), name)
    return u'{{%{}%}}'.format(full)


@parsexp(r'\(:([^)]*)\)',
    (name, block, variable),
    (string, block, variable, word))
def attribute(name, value):
    return name, value


@parsexp(r'\(([^)]*)\)',
    (tag, block, variable))
def element((tag, attrs), contents):
    body = []
    for elem in contents:
        (attrs if isinstance(elem, tuple) else body).append(elem)
    return u'<{}>{}</{}>'.format(
            ' '.join((tag, _attrs(attrs))),
            ''.join(body),
            tag)


@parsexp(r'\(\/([^)]*)\)',
    (tag, block, variable),
    (attribute,))
def closer((tag, basic), attrs):
    return u'<{}{}>'.format(
            ' '.join((tag, _attrs(basic + attrs))),
            '/' if CLOSE_SLASH else '')

# Module :::1

top = (comment, element, closer, block, variable, string)
